# Mac Audio Keepalive v2.0 - Implementation Specification

**Project**: Mac Audio Keepalive Enhancement
**Version**: 1.2 → 2.0
**Scope**: Recommended (Universal Binary + Dual Modes + Preferences UI)
**Estimated Effort**: 10-15 hours
**Target**: macOS 11.0+ (Big Sur and later)

---

## Executive Summary

This specification defines the implementation of Mac Audio Keepalive v2.0, adding:
- **Native Apple Silicon support** via Universal Binary
- **Flexible audio modes**: Continuous (current) + Interval (periodic pulses)
- **User preferences**: Mode selection, interval configuration
- **Professional UI**: Preferences window with standard macOS patterns

**Scope Decisions**:
- ✅ Universal Binary (arm64 + x86_64) - maintains Intel compatibility
- ✅ Dual audio modes - both continuous and interval available
- ⚠️ System default audio output only - device selection deferred to v2.1
- ✅ Preferences window - standard macOS UI pattern

---

## 1. Requirements Summary

### 1.1 Functional Requirements

**FR1: Apple Silicon Native Support**
- App must run natively on Apple Silicon Macs (no Rosetta 2)
- Maintain Intel Mac compatibility (Universal Binary)
- Target: macOS 11.0+ (Big Sur - first ARM64 macOS)

**FR2: Audio Mode Flexibility**
- **Continuous Mode**: Current behavior - constant inaudible tone
- **Interval Mode**: Periodic inaudible pulse at user-defined interval
- User selects mode via preferences
- Mode persists across app restarts

**FR3: Interval Configuration**
- User configurable interval: 5, 10, 15, 20, 25, 30 minutes
- Default: 25 minutes (user's use case)
- Interval persists across app restarts

**FR4: Preferences UI**
- Menu bar item: "Preferences..." opens preferences window
- Window sections:
  - Audio Mode selection (radio buttons)
  - Interval configuration (dropdown/slider)
  - Visual feedback showing current state
- Standard macOS window patterns (⌘W to close, ⌘, shortcut)

**FR5: Settings Persistence**
- All preferences saved via NSUserDefaults
- Restore on app launch
- Sensible defaults for first launch

**FR6: Inaudible Audio**
- All audio (continuous and interval) remains inaudible
- Maintain current proven approach: sparse pulse, 1% volume, 8-bit mono

### 1.2 Non-Functional Requirements

**NFR1: Performance**
- CPU usage: < 0.2% (currently <0.1%, slight increase acceptable)
- Memory footprint: < 5MB (currently ~100KB, allow room for UI)
- Battery impact: Very Low (same as current)

**NFR2: Compatibility**
- macOS 11.0 (Big Sur) minimum
- Intel + Apple Silicon architectures
- Backwards compatible settings (graceful handling of missing preferences)

**NFR3: Code Quality**
- Follow existing code style (unconventional spacing maintained)
- ARC enabled (migrate from manual memory management)
- Error handling for all AudioQueue operations
- Comprehensive inline documentation

**NFR4: User Experience**
- Preferences window opens instantly (< 100ms)
- Settings apply immediately (no restart required)
- Clear visual feedback for current mode/status

---

## 2. Architecture Design

### 2.1 Component Overview

```
┌────────────────────────────────────────────────────────┐
│                    NSApplication                       │
│                       (main.m)                         │
└─────────────────────────┬──────────────────────────────┘
                          │
                ┌─────────▼──────────┐
                │   AppDelegate      │  ← Application Coordinator
                │  - Menu Management │
                │  - Lifecycle       │
                │  - Coordinator     │
                └─────┬───────┬──────┘
                      │       │
         ┌────────────┘       └─────────────┐
         │                                   │
┌────────▼────────────┐          ┌──────────▼──────────┐
│  PreferencesWindow  │          │  AudioController    │
│  - UI Components    │          │  - Mode Management  │
│  - Settings Binding │          │  - Playback Control │
└────────┬────────────┘          └──────────┬──────────┘
         │                                   │
         │                          ┌────────┴────────┐
         │                          │                 │
         │                  ┌───────▼──────┐  ┌──────▼────────┐
         │                  │  WavePlayer  │  │ AudioScheduler│
         │                  │  - AudioQueue│  │ - Timer Mgmt  │
         │                  │  - Start/Stop│  │ - Scheduling  │
         │                  └──────────────┘  └───────────────┘
         │
┌────────▼────────────┐
│  SettingsManager    │  ← Data Persistence
│  - NSUserDefaults   │
│  - Load/Save/Reset  │
└─────────────────────┘
```

### 2.2 Component Responsibilities

**AppDelegate** (Enhanced)
- Creates and owns all major components
- Manages menu bar UI and menu items
- Coordinates between preferences and audio controller
- Handles app lifecycle events

**AudioController** (New)
- Central audio management component
- Owns WavePlayer instance
- Owns AudioScheduler instance
- Implements mode switching logic
- Responds to settings changes

**WavePlayer** (Refactored)
- Pure audio generation engine
- Adds start() and stop() methods
- No longer auto-starts on init
- Simplified to single responsibility

**AudioScheduler** (New)
- Manages interval timing
- Uses DispatchSourceTimer for precision
- Triggers WavePlayer start/stop on schedule
- Handles timer lifecycle

**SettingsManager** (New)
- Centralized settings persistence
- NSUserDefaults wrapper
- Type-safe getters/setters
- Default value management

**PreferencesWindowController** (New)
- NSWindowController subclass
- Manages preferences window UI
- Bindings to SettingsManager
- Notifies AppDelegate of changes

### 2.3 Data Flow

**App Launch Flow**:
```
1. main.m → NSApplicationMain()
2. AppDelegate.applicationDidFinishLaunching:
   - Load settings (SettingsManager)
   - Create AudioController
   - Create PreferencesWindowController (lazy)
   - Setup menu bar UI
   - Start audio based on saved mode
```

**Settings Change Flow**:
```
1. User changes setting in PreferencesWindow
2. PreferencesWindow → SettingsManager.save()
3. PreferencesWindow → AppDelegate.settingsDidChange()
4. AppDelegate → AudioController.applySettings()
5. AudioController → reconfigures WavePlayer/AudioScheduler
```

**Interval Mode Flow**:
```
1. AudioController.startIntervalMode()
2. AudioScheduler.start(interval: 25 * 60 seconds)
3. Timer fires → AudioScheduler.timerFired()
4. AudioScheduler → WavePlayer.start()
5. WavePlayer plays for 1 second
6. WavePlayer.stop()
7. Wait for next timer fire
```

---

## 3. Component Specifications

### 3.1 SettingsManager

**File**: `SettingsManager.h` / `SettingsManager.m`

**Responsibilities**:
- Load/save user preferences
- Provide default values
- Type-safe access to settings

**Interface**:
```objc
typedef NS_ENUM(NSInteger, AudioMode) {
    AudioModeContinuous = 0,
    AudioModeInterval = 1
};

@interface SettingsManager : NSObject

+ (instancetype)sharedManager;

// Settings Properties
@property (nonatomic, assign) AudioMode audioMode;
@property (nonatomic, assign) NSInteger intervalMinutes;  // 5, 10, 15, 20, 25, 30

// Methods
- (void)loadSettings;
- (void)saveSettings;
- (void)resetToDefaults;

@end
```

**Default Values**:
- `audioMode`: `AudioModeContinuous` (preserve current behavior for existing users)
- `intervalMinutes`: `25` (user's requirement)

**NSUserDefaults Keys**:
- `kSettingsKeyAudioMode`: @"audioMode"
- `kSettingsKeyIntervalMinutes`: @"intervalMinutes"

---

### 3.2 WavePlayer (Refactored)

**Files**: `WavePlayer.h` / `WavePlayer.m`

**Changes from v1.2**:
- ❌ Remove auto-start in init
- ✅ Add explicit `start` method
- ✅ Add explicit `stop` method
- ✅ Add `isPlaying` state property
- ✅ Add error handling for AudioQueue operations
- ✅ Migrate to ARC (remove manual dealloc)

**Interface**:
```objc
@interface WavePlayer : NSObject

@property (nonatomic, assign, readonly) BOOL isPlaying;

- (instancetype)init;
- (BOOL)start;  // Returns YES on success, NO on error
- (void)stop;
- (void)dispose;  // Explicit cleanup (called from dealloc)

@end
```

**Implementation Notes**:
- `init`: Setup audio format, create AudioQueue, allocate buffers, **DO NOT start**
- `start`: Fill buffers (if needed), enqueue buffers, AudioQueueStart()
- `stop`: AudioQueueStop(), clear buffers
- `dispose`: AudioQueueDispose()
- Error handling: Check OSStatus return values, log errors

**Audio Parameters** (unchanged):
- Sample rate: 44100 Hz
- Bit depth: 8-bit
- Channels: Mono (1)
- Buffer size: 44100 samples (1 second)
- Pulse pattern: 1 every 200 samples (220 Hz fundamental)
- Volume: 1% (0.01)

---

### 3.3 AudioScheduler

**Files**: `AudioScheduler.h` / `AudioScheduler.m`

**Responsibilities**:
- Schedule periodic audio pulses at user-defined interval
- Manage timer lifecycle
- Control WavePlayer start/stop

**Interface**:
```objc
@interface AudioScheduler : NSObject

@property (nonatomic, weak) WavePlayer* wavePlayer;  // Weak to avoid retain cycle
@property (nonatomic, assign, readonly) BOOL isScheduling;

- (instancetype)initWithWavePlayer:(WavePlayer*)player;
- (void)startWithIntervalMinutes:(NSInteger)minutes;
- (void)stop;

@end
```

**Implementation Details**:
- Use `dispatch_source_t` timer (GCD) for precision and low overhead
- Timer fires every `minutes * 60` seconds
- On fire: `[wavePlayer start]` → wait 1 second → `[wavePlayer stop]`
- Handle edge cases: timer invalidation, app sleep/wake

**Timer Setup**:
```objc
dispatch_source_t timer = dispatch_source_create(
    DISPATCH_SOURCE_TYPE_TIMER,
    0,
    0,
    dispatch_get_main_queue()
);
dispatch_source_set_timer(
    timer,
    dispatch_time(DISPATCH_TIME_NOW, intervalNanoseconds),
    intervalNanoseconds,
    0  // leeway
);
```

---

### 3.4 AudioController

**Files**: `AudioController.h` / `AudioController.m`

**Responsibilities**:
- Central audio coordination
- Mode switching logic
- Settings application

**Interface**:
```objc
@interface AudioController : NSObject

- (instancetype)init;
- (void)startWithMode:(AudioMode)mode intervalMinutes:(NSInteger)minutes;
- (void)stop;
- (void)applySettings;  // Reads from SettingsManager, reconfigures

@end
```

**Implementation Logic**:
```objc
- (void)applySettings {
    SettingsManager* settings = [SettingsManager sharedManager];

    // Stop current mode
    [self stop];

    // Start new mode
    if (settings.audioMode == AudioModeContinuous) {
        [wavePlayer start];  // Just start and leave running
    } else {  // AudioModeInterval
        [audioScheduler startWithIntervalMinutes:settings.intervalMinutes];
    }
}

- (void)stop {
    [audioScheduler stop];
    [wavePlayer stop];
}
```

**Lifecycle**:
- Created by AppDelegate on launch
- Persists for app lifetime
- Responds to settings changes via `applySettings`

---

### 3.5 PreferencesWindowController

**Files**:
- `PreferencesWindowController.h` / `PreferencesWindowController.m`
- `PreferencesWindow.xib` (Interface Builder file)

**Responsibilities**:
- Manage preferences window UI
- Handle user input
- Update SettingsManager
- Notify AppDelegate of changes

**Interface**:
```objc
@protocol PreferencesWindowDelegate <NSObject>
- (void)preferencesDidChange;
@end

@interface PreferencesWindowController : NSWindowController

@property (nonatomic, weak) id<PreferencesWindowDelegate> delegate;

- (instancetype)init;
- (void)showWindow:(id)sender;

@end
```

**UI Components** (in .xib):
```
┌─────────────────────────────────────────────┐
│  Mac Audio Keepalive - Preferences          │
├─────────────────────────────────────────────┤
│                                             │
│  Audio Mode:                                │
│  ○ Continuous (prevents HDMI/optical drops) │
│  ○ Interval (prevents speaker standby)      │
│                                             │
│  Interval Duration:                         │
│  [Dropdown: 5, 10, 15, 20, 25, 30 minutes]  │
│                                             │
│  Status: ✓ Audio keepalive active           │
│                                             │
│         [Reset to Defaults]                 │
│                                             │
└─────────────────────────────────────────────┘
```

**IBOutlet Properties**:
```objc
@property (weak) IBOutlet NSMatrix* modeRadioButtons;
@property (weak) IBOutlet NSPopUpButton* intervalPopup;
@property (weak) IBOutlet NSTextField* statusLabel;
```

**Behavior**:
- Mode change → immediately save to SettingsManager → notify delegate
- Interval change → immediately save → notify delegate
- "Reset to Defaults" → SettingsManager.resetToDefaults() → update UI → notify delegate
- Window close (⌘W) → hides window (doesn't quit app)

---

### 3.6 AppDelegate (Enhanced)

**Changes from v1.2**:
- ✅ Add AudioController property
- ✅ Add PreferencesWindowController property (lazy-loaded)
- ✅ Add "Preferences..." menu item
- ✅ Implement PreferencesWindowDelegate
- ✅ Load settings on launch

**New Interface**:
```objc
@interface AppDelegate : NSObject <NSApplicationDelegate, PreferencesWindowDelegate>
{
    NSStatusItem* statusItem;
    AudioController* audioController;
    PreferencesWindowController* preferencesWindow;
}

- (void)showPreferences:(id)sender;
- (void)preferencesDidChange;  // PreferencesWindowDelegate

@end
```

**Menu Changes**:
```objc
- (void)applicationDidFinishLaunching:(NSNotification*)theNotification
{
    NSMenu* menu = [[NSMenu alloc] init];

    [menu addItemWithTitle:@"Running" action:nil keyEquivalent:@""];
    [menu addItem:[NSMenuItem separatorItem]];
    [menu addItemWithTitle:@"Preferences..." action:@selector(showPreferences:) keyEquivalent:@","];  // NEW
    [menu addItem:[NSMenuItem separatorItem]];
    [menu addItemWithTitle:@"Donate if you like the app" action:@selector(support) keyEquivalent:@""];
    [menu addItemWithTitle:@"Check for updates" action:@selector(update) keyEquivalent:@""];
    [menu addItemWithTitle:@"Quit" action:@selector(terminate) keyEquivalent:@""];

    // Setup status item (unchanged)...

    // Initialize audio system
    audioController = [[AudioController alloc] init];
    [audioController applySettings];  // Starts audio based on saved settings
}
```

**Preferences Handling**:
```objc
- (void)showPreferences:(id)sender
{
    if (!preferencesWindow) {
        preferencesWindow = [[PreferencesWindowController alloc] init];
        preferencesWindow.delegate = self;
    }
    [preferencesWindow showWindow:sender];
}

- (void)preferencesDidChange
{
    [audioController applySettings];  // Reconfigure audio based on new settings
}
```

---

## 4. File Structure

### 4.1 New File Organization

```
Mac Audio Keepalive/
├── main.m                              (unchanged)
├── AppDelegate.h                        (enhanced)
├── AppDelegate.m                        (enhanced)
├── WavePlayer.h                         (refactored)
├── WavePlayer.m                         (refactored)
├── AudioController.h                    (NEW)
├── AudioController.m                    (NEW)
├── AudioScheduler.h                     (NEW)
├── AudioScheduler.m                     (NEW)
├── SettingsManager.h                    (NEW)
├── SettingsManager.m                    (NEW)
├── PreferencesWindowController.h        (NEW)
├── PreferencesWindowController.m        (NEW)
├── PreferencesWindow.xib                (NEW)
├── Info.plist                           (updated)
├── Assets.xcassets/
│   ├── icon.png                         (unchanged)
│   └── icon@2x.png                      (unchanged)
└── Base.lproj/
    └── MainMenu.xib                     (unchanged)
```

### 4.2 Line Count Estimate

| Component | Current LOC | New LOC | Delta |
|-----------|------------|---------|-------|
| main.m | 13 | 13 | 0 |
| AppDelegate.h/m | 55 | 110 | +55 |
| WavePlayer.h/m | 153 | 180 | +27 |
| AudioController.h/m | 0 | 120 | +120 |
| AudioScheduler.h/m | 0 | 80 | +80 |
| SettingsManager.h/m | 0 | 90 | +90 |
| PreferencesWindowController.h/m | 0 | 100 | +100 |
| **Total** | **221** | **~693** | **+472** |

**Note**: .xib files not counted (visual UI, not code)

---

## 5. Build Configuration

### 5.1 Xcode Project Settings

**General Tab**:
- Deployment Target: macOS 11.0
- Version: 2.0
- Build: 2.0.0

**Build Settings**:
```
ARCHS = arm64 x86_64                    // Universal Binary
VALID_ARCHS = arm64 x86_64
ONLY_ACTIVE_ARCH = NO                    // Build both in Release
MACOSX_DEPLOYMENT_TARGET = 11.0
ENABLE_HARDENED_RUNTIME = YES            // Required for notarization
CLANG_ENABLE_OBJC_ARC = YES              // Enable ARC
CODE_SIGN_IDENTITY = Developer ID        // For distribution
```

**Signing & Capabilities**:
- Developer ID Application certificate
- Hardened Runtime enabled
- Audio Input: NO (not needed)

### 5.2 Info.plist Updates

```xml
<key>CFBundleShortVersionString</key>
<string>2.0</string>

<key>CFBundleVersion</key>
<string>2.0.0</string>

<key>LSMinimumSystemVersion</key>
<string>11.0</string>

<!-- Ensure LSUIElement remains true (menu bar only app) -->
<key>LSUIElement</key>
<true/>
```

---

## 6. Implementation Plan

### 6.1 Phase 1: Foundation (3-4 hours)

**Goal**: Setup infrastructure without breaking existing functionality

**Tasks**:
1. **Enable ARC** (30 min)
   - Update build settings: CLANG_ENABLE_OBJC_ARC = YES
   - Remove manual `dealloc` from WavePlayer
   - Remove `[super dealloc]` comment
   - Build and test

2. **Create SettingsManager** (1 hour)
   - Implement .h and .m files
   - Add default values
   - Add NSUserDefaults keys
   - Unit test loading/saving (manual validation)

3. **Update Build Settings for Universal Binary** (30 min)
   - Set ARCHS = arm64 x86_64
   - Set deployment target to 11.0
   - Build for both architectures
   - Verify binary: `file Mac\ Audio\ Keepalive.app/Contents/MacOS/Mac\ Audio\ Keepalive`
   - Should show: "Mach-O universal binary with 2 architectures"

4. **Refactor WavePlayer** (1.5 hours)
   - Add `start`, `stop`, `dispose` methods
   - Add `isPlaying` property
   - Add error handling (OSStatus checks)
   - Update init to NOT auto-start
   - Test manually (start/stop cycles)

**Validation**: App builds, runs on both Intel and Apple Silicon, SettingsManager works

---

### 6.2 Phase 2: Audio System (3-4 hours)

**Goal**: Implement interval mode and audio controller

**Tasks**:
1. **Create AudioScheduler** (2 hours)
   - Implement timer using GCD dispatch_source
   - Test timer firing at correct intervals
   - Integrate with WavePlayer (start/stop calls)
   - Handle timer lifecycle (start/stop/invalidate)

2. **Create AudioController** (1.5 hours)
   - Implement mode switching logic
   - Integrate with SettingsManager
   - Implement `applySettings` method
   - Test continuous mode (should work like v1.2)
   - Test interval mode (timer fires, audio pulses)

3. **Update AppDelegate** (30 min)
   - Add AudioController property
   - Initialize AudioController in `applicationDidFinishLaunching:`
   - Remove direct WavePlayer usage
   - Test app launch with both modes

**Validation**: Both continuous and interval modes work correctly, settings persist

---

### 6.3 Phase 3: User Interface (4-5 hours)

**Goal**: Build preferences UI

**Tasks**:
1. **Create PreferencesWindow.xib** (2 hours)
   - Design UI layout in Interface Builder
   - Add mode radio buttons (Continuous/Interval)
   - Add interval popup (5, 10, 15, 20, 25, 30 min)
   - Add status label
   - Add "Reset to Defaults" button
   - Set window properties (title, size, resizable:NO)

2. **Create PreferencesWindowController** (2 hours)
   - Implement NSWindowController subclass
   - Connect IBOutlets to .xib
   - Implement IBAction methods (mode change, interval change, reset)
   - Implement delegate pattern
   - Bind UI to SettingsManager values
   - Test window open/close, setting changes

3. **Update AppDelegate Menu** (30 min)
   - Add "Preferences..." menu item
   - Implement `showPreferences:` action
   - Implement `preferencesDidChange` delegate method
   - Test menu → preferences → settings change → audio reconfiguration

4. **Polish UI** (30 min)
   - Add tooltips
   - Test keyboard shortcuts (⌘W, ⌘,)
   - Test window behavior (close vs minimize)
   - Verify status label updates

**Validation**: Preferences window works, settings persist, audio responds to changes

---

### 6.4 Phase 4: Testing & Polish (2-3 hours)

**Goal**: Ensure quality and reliability

**Tasks**:
1. **Functional Testing** (1 hour)
   - Test continuous mode on Intel Mac
   - Test continuous mode on Apple Silicon Mac
   - Test interval mode with various intervals (5, 10, 25 min)
   - Test mode switching while app running
   - Test app restart (settings persist)
   - Test "Reset to Defaults"
   - Test quit during interval mode (timer cleanup)

2. **Edge Case Testing** (30 min)
   - Test rapid mode switching
   - Test changing interval while interval mode active
   - Test system sleep/wake during interval mode
   - Test audio device disconnect (system default handling)

3. **Code Quality** (1 hour)
   - Add inline documentation to all new classes
   - Add header comments explaining purpose
   - Review error handling completeness
   - Run static analyzer (Xcode Analyze)
   - Fix any warnings or issues

4. **Documentation** (30 min)
   - Update README.md with v2.0 features
   - Update CLAUDE.md with new architecture
   - Add CHANGELOG.md entry for v2.0

**Validation**: App stable, no crashes, all features work as specified

---

### 6.5 Phase 5: Release Preparation (1 hour)

**Goal**: Prepare for distribution

**Tasks**:
1. **Version Bumping** (15 min)
   - Update Info.plist: 1.2 → 2.0
   - Update README version references

2. **Build Release Binary** (15 min)
   - Archive build in Xcode
   - Export with Developer ID signing
   - Verify universal binary: `lipo -info`

3. **Notarization** (30 min)
   - Submit to Apple notarization service
   - Staple notarization ticket
   - Verify Gatekeeper acceptance

**Deliverable**: Signed, notarized Mac Audio Keepalive 2.0.app

---

## 7. Testing Strategy

### 7.1 Manual Test Cases

**Test Case 1: Fresh Install**
- Delete existing app and preferences
- Launch v2.0 for first time
- Verify: Continuous mode active (default)
- Verify: Interval default is 25 minutes

**Test Case 2: Continuous Mode**
- Set mode to Continuous in preferences
- Verify: Audio starts immediately
- Verify: Audio continues playing
- Quit app, relaunch
- Verify: Still in Continuous mode

**Test Case 3: Interval Mode (Short Interval)**
- Set mode to Interval, 5 minutes
- Wait 5 minutes
- Verify: Audio pulse occurs (~1 second)
- Verify: Audio stops after pulse
- Wait another 5 minutes
- Verify: Pulse occurs again

**Test Case 4: Mode Switching**
- Start in Continuous mode (audio playing)
- Switch to Interval mode
- Verify: Continuous audio stops
- Verify: Interval timer starts
- Switch back to Continuous
- Verify: Audio resumes immediately

**Test Case 5: Settings Persistence**
- Set Interval mode, 10 minutes
- Quit app
- Relaunch app
- Verify: Interval mode active, 10 min interval

**Test Case 6: Universal Binary**
- Build app
- Run `file` command: verify "2 architectures"
- Test on Intel Mac: verify native execution
- Test on Apple Silicon Mac: verify native execution (check Activity Monitor: "Kind: Apple")

**Test Case 7: System Sleep/Wake**
- Set Interval mode, 5 minutes
- Wait for timer to fire (verify pulse)
- Put Mac to sleep
- Wake Mac
- Wait 5 minutes
- Verify: Timer fires correctly after wake

### 7.2 Regression Testing

Ensure v1.2 functionality preserved:

- ✅ Menu bar icon appears
- ✅ Menu items work (Donate, Check for Updates, Quit)
- ✅ App quits cleanly
- ✅ Audio is inaudible
- ✅ Minimal CPU/memory usage
- ✅ No visual window (LSUIElement = true)

---

## 8. Migration Strategy

### 8.1 Backwards Compatibility

**Scenario 1: Fresh Install (New User)**
- No existing preferences
- SettingsManager provides defaults
- Continuous mode active (familiar behavior)
- User discovers Preferences when ready

**Scenario 2: Upgrade from v1.2 (Existing User)**
- No existing preferences (v1.2 had none)
- SettingsManager provides defaults
- Continuous mode active (identical to v1.2 behavior)
- User notices new "Preferences..." menu item
- User explores new features at own pace

**Scenario 3: Downgrade to v1.2 (Rollback)**
- v1.2 ignores NSUserDefaults keys
- v1.2 works as before
- No data loss or corruption

**Conclusion**: No migration code needed, defaults provide smooth upgrade path

### 8.2 Deployment

**Distribution Channels**:
1. **Direct Download** (milgra.com)
   - Replace v1.2 with v2.0
   - Update download page with v2.0 features
   - Keep v1.2 available as "Legacy Version" (optional)

2. **GitHub Release**
   - Tag: v2.0.0
   - Release notes with feature list
   - Universal binary .dmg or .app.zip

3. **Mac App Store** (future consideration)
   - Requires sandboxing (deferred)
   - App Review process

**Update Notification**:
- v1.2 "Check for Updates" menu item opens webpage
- Webpage shows v2.0 available with feature highlights
- Manual download/install (no auto-update)

---

## 9. Risk Assessment

### 9.1 Technical Risks

**Risk 1: AudioQueue Lifecycle Management**
- **Severity**: Medium
- **Probability**: Medium
- **Impact**: App crashes if start/stop not properly sequenced
- **Mitigation**: Thorough testing of start/stop cycles, state management
- **Contingency**: Add state machine to prevent invalid transitions

**Risk 2: Timer Precision**
- **Severity**: Low
- **Probability**: Low
- **Impact**: Interval timing drift over long periods
- **Mitigation**: GCD timers are precise, system handles sleep/wake
- **Contingency**: Accept slight drift (not critical for use case)

**Risk 3: Settings Corruption**
- **Severity**: Low
- **Probability**: Very Low
- **Impact**: Invalid settings could cause startup failure
- **Mitigation**: Validate all loaded settings, fall back to defaults
- **Contingency**: "Reset to Defaults" button, NSUserDefaults is robust

**Risk 4: Universal Binary Build Issues**
- **Severity**: Medium
- **Probability**: Low
- **Impact**: Build failures on unfamiliar architectures
- **Mitigation**: Standard Xcode settings, well-documented process
- **Contingency**: Test build early in Phase 1, adjust settings as needed

### 9.2 User Experience Risks

**Risk 1: Confusion About Modes**
- **Severity**: Low
- **Probability**: Medium
- **Impact**: Users unsure which mode to use
- **Mitigation**: Clear UI labels, tooltip descriptions
- **Contingency**: Add "Help" button with mode explanations

**Risk 2: Unexpected Behavior After Upgrade**
- **Severity**: Low
- **Probability**: Low
- **Impact**: Users expect v1.2 behavior (continuous)
- **Mitigation**: Default to Continuous mode (preserves v1.2 behavior)
- **Contingency**: Release notes explain new features are opt-in

### 9.3 Project Risks

**Risk 1: Scope Creep**
- **Severity**: Medium
- **Probability**: Medium
- **Impact**: Timeline extends beyond 15 hours
- **Mitigation**: Strict adherence to recommended scope, defer device selection
- **Contingency**: Ship v2.0 without device selection, add in v2.1

**Risk 2: Testing Insufficient**
- **Severity**: Medium
- **Probability**: Low
- **Impact**: Bugs in production release
- **Mitigation**: Comprehensive test cases, manual testing on both architectures
- **Contingency**: Rapid patch release (v2.0.1) if critical bugs found

---

## 10. Success Criteria

### 10.1 Functional Success

- ✅ App builds as Universal Binary (arm64 + x86_64)
- ✅ Runs natively on Apple Silicon (Activity Monitor: "Kind: Apple")
- ✅ Continuous mode works identically to v1.2
- ✅ Interval mode fires at configured intervals (±5 seconds acceptable)
- ✅ All settings persist across app restarts
- ✅ Preferences window opens and functions correctly
- ✅ No crashes during normal operation (continuous mode + interval mode + switching)

### 10.2 Non-Functional Success

- ✅ CPU usage < 0.2% (currently <0.1%)
- ✅ Memory footprint < 5MB (currently ~100KB)
- ✅ Preferences window opens < 100ms
- ✅ Settings changes apply immediately (no restart required)
- ✅ Code quality: no compiler warnings, static analyzer clean
- ✅ Documentation: all new components have header/inline docs

### 10.3 User Acceptance

- ✅ User can select between Continuous and Interval modes
- ✅ User can configure interval from 5-30 minutes
- ✅ User can see current mode status
- ✅ User can reset to defaults if confused
- ✅ Upgrade from v1.2 is seamless (no manual intervention)

---

## 11. Post-Launch Roadmap (Future Versions)

### v2.1 - Audio Device Selection
- Add device picker in preferences
- Enumerate available audio outputs
- Route AudioQueue to selected device
- Persist device selection
- Handle device connect/disconnect

### v2.2 - Advanced Settings
- Adjustable volume (0.5% - 5%)
- Adjustable pulse pattern (frequency)
- Visual pulse indicator (menu bar icon animation)
- Statistics (uptime, pulse count)

### v2.3 - Automation
- Active hours scheduling (only run during work hours)
- Audio activity detection (pause if other audio playing)
- Pause/resume via menu bar

### v3.0 - Mac App Store
- Sandboxing implementation
- App Store submission
- In-app purchase for "Pro" features (optional)

---

## 12. References

### Technical Documentation
- [AudioQueue Programming Guide](https://developer.apple.com/library/archive/documentation/MusicAudio/Conceptual/AudioQueueProgrammingGuide/)
- [NSUserDefaults Class Reference](https://developer.apple.com/documentation/foundation/nsuserdefaults)
- [Universal Binary Programming Guidelines](https://developer.apple.com/documentation/xcode/building-a-universal-macos-binary)
- [GCD Dispatch Sources](https://developer.apple.com/documentation/dispatch/dispatchsource)

### Project Files
- Current analysis: `claudedocs/code_analysis_report.md`
- Codebase guide: `CLAUDE.md`
- Project README: `README.md`

---

## Appendix A: Code Snippets

### A.1 SettingsManager Implementation Example

```objc
// SettingsManager.h
#import <Foundation/Foundation.h>

typedef NS_ENUM(NSInteger, AudioMode) {
    AudioModeContinuous = 0,
    AudioModeInterval = 1
};

@interface SettingsManager : NSObject

+ (instancetype)sharedManager;

@property (nonatomic, assign) AudioMode audioMode;
@property (nonatomic, assign) NSInteger intervalMinutes;

- (void)loadSettings;
- (void)saveSettings;
- (void)resetToDefaults;

@end

// SettingsManager.m
#import "SettingsManager.h"

static NSString* const kSettingsKeyAudioMode = @"audioMode";
static NSString* const kSettingsKeyIntervalMinutes = @"intervalMinutes";

static NSInteger const kDefaultIntervalMinutes = 25;
static AudioMode const kDefaultAudioMode = AudioModeContinuous;

@implementation SettingsManager

+ (instancetype)sharedManager {
    static SettingsManager* instance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        instance = [[SettingsManager alloc] init];
        [instance loadSettings];
    });
    return instance;
}

- (void)loadSettings {
    NSUserDefaults* defaults = [NSUserDefaults standardUserDefaults];

    if ([defaults objectForKey:kSettingsKeyAudioMode]) {
        _audioMode = [defaults integerForKey:kSettingsKeyAudioMode];
    } else {
        _audioMode = kDefaultAudioMode;
    }

    if ([defaults objectForKey:kSettingsKeyIntervalMinutes]) {
        _intervalMinutes = [defaults integerForKey:kSettingsKeyIntervalMinutes];
    } else {
        _intervalMinutes = kDefaultIntervalMinutes;
    }

    // Validate
    if (_intervalMinutes < 5 || _intervalMinutes > 30) {
        _intervalMinutes = kDefaultIntervalMinutes;
    }
}

- (void)saveSettings {
    NSUserDefaults* defaults = [NSUserDefaults standardUserDefaults];
    [defaults setInteger:_audioMode forKey:kSettingsKeyAudioMode];
    [defaults setInteger:_intervalMinutes forKey:kSettingsKeyIntervalMinutes];
    [defaults synchronize];
}

- (void)resetToDefaults {
    _audioMode = kDefaultAudioMode;
    _intervalMinutes = kDefaultIntervalMinutes;
    [self saveSettings];
}

@end
```

### A.2 WavePlayer Refactored Start Method

```objc
- (BOOL)start {
    if (isPlaying) {
        return YES;  // Already playing
    }

    // Refill buffers (in case previously stopped)
    for (int bufferCount = 0; bufferCount < 2; bufferCount++) {
        for (int index = 0; index < kBufferSize / 4; index++) {
            int* buffer = (int*)(frameBuffers[bufferCount]->mAudioData);
            buffer[index] = (index % 200) == 0 ? 1 : 0;
        }
        frameBuffers[bufferCount]->mAudioDataByteSize = kBufferSize;

        OSStatus status = AudioQueueEnqueueBuffer(audioQueue, frameBuffers[bufferCount], 0, NULL);
        if (status != noErr) {
            NSLog(@"Failed to enqueue buffer: %d", status);
            return NO;
        }
    }

    OSStatus status = AudioQueueStart(audioQueue, NULL);
    if (status != noErr) {
        NSLog(@"Failed to start audio queue: %d", status);
        return NO;
    }

    isPlaying = YES;
    return YES;
}

- (void)stop {
    if (!isPlaying) {
        return;  // Already stopped
    }

    AudioQueueStop(audioQueue, YES);  // Immediate stop
    isPlaying = NO;
}
```

### A.3 AudioScheduler Timer Implementation

```objc
- (void)startWithIntervalMinutes:(NSInteger)minutes {
    [self stop];  // Stop any existing timer

    int64_t intervalNanoseconds = minutes * 60 * NSEC_PER_SEC;

    timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());

    dispatch_source_set_timer(
        timer,
        dispatch_time(DISPATCH_TIME_NOW, intervalNanoseconds),
        intervalNanoseconds,
        0  // No leeway
    );

    __weak typeof(self) weakSelf = self;
    dispatch_source_set_event_handler(timer, ^{
        [weakSelf timerFired];
    });

    dispatch_resume(timer);
    isScheduling = YES;
}

- (void)timerFired {
    if (!wavePlayer) {
        return;
    }

    // Start audio for 1 second pulse
    [wavePlayer start];

    // Stop after 1 second
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC), dispatch_get_main_queue(), ^{
        [self.wavePlayer stop];
    });
}

- (void)stop {
    if (timer) {
        dispatch_source_cancel(timer);
        timer = nil;
    }
    isScheduling = NO;
}
```

---

## Appendix B: UI Mockups

### Preferences Window Layout

```
┌───────────────────────────────────────────────────────┐
│  ●  ●  ●    Mac Audio Keepalive - Preferences         │
├───────────────────────────────────────────────────────┤
│                                                       │
│  Audio Mode                                           │
│  ┌─────────────────────────────────────────────────┐ │
│  │  ○  Continuous Mode                             │ │
│  │      Prevents HDMI/optical audio dropouts       │ │
│  │                                                  │ │
│  │  ○  Interval Mode                               │ │
│  │      Prevents speaker standby with periodic     │ │
│  │      inaudible pulses                           │ │
│  └─────────────────────────────────────────────────┘ │
│                                                       │
│  Interval Settings                                    │
│  ┌─────────────────────────────────────────────────┐ │
│  │  Play pulse every:  [ 25 minutes ▼]            │ │
│  │                                                  │ │
│  │  Available intervals: 5, 10, 15, 20, 25, 30 min│ │
│  └─────────────────────────────────────────────────┘ │
│                                                       │
│  Status                                               │
│  ┌─────────────────────────────────────────────────┐ │
│  │  ✓  Audio keepalive is active                  │ │
│  │     Mode: Interval (25 minutes)                │ │
│  │     Next pulse in: 18 minutes 32 seconds       │ │
│  └─────────────────────────────────────────────────┘ │
│                                                       │
│                       [Reset to Defaults]             │
│                                                       │
└───────────────────────────────────────────────────────┘
```

---

## Document Control

**Version**: 1.0
**Date**: 2025-11-16
**Author**: Claude Code (SuperClaude Framework)
**Status**: Final - Ready for Implementation
**Review**: User approved recommended scope
**Next Action**: Begin Phase 1 implementation

---

**END OF SPECIFICATION**
